use anyhow::{Context, Result};
use protocol::{EdgeIR, EdgeType, Language as ProtoLanguage, OccurrenceIR, OccurrenceRole, Resolution, Span, SymbolIR, SymbolKind, Version};
use std::collections::HashMap;
use std::path::Path;
use tree_sitter::{Node, Parser};

mod version_detector;
use version_detector::CppVersionDetector;

#[cfg(test)]
mod debug;
#[cfg(test)]
mod edge_cases;
#[cfg(test)]
mod complex_tests;
#[cfg(test)]
mod strict_tests;
#[cfg(test)]
mod error_handling_tests;
#[cfg(test)]
mod stress_tests;

pub struct CppHarness {
    parser: Parser,
    is_cpp: bool, // true for C++, false for C
    version: Option<Version>, // Detected or specified version
}

impl CppHarness {
    fn create_symbol(
        &self,
        id: String,
        lang: ProtoLanguage,
        kind: SymbolKind,
        name: String,
        fqn: String,
        signature: Option<String>,
        file_path: String,
        span: Span,
        visibility: Option<String>,
        doc: Option<String>,
        sig_hash: String,
    ) -> SymbolIR {
        SymbolIR {
            id,
            lang,
            lang_version: self.version.clone(),
            kind,
            name,
            fqn,
            signature,
            file_path,
            span,
            visibility,
            doc,
            sig_hash,
        }
    }
    
    pub fn new_cpp() -> Result<Self> {
        let mut parser = Parser::new();
        let lang = tree_sitter_cpp::language();
        parser.set_language(lang).context("Failed to set C++ language")?;
        Ok(Self { parser, is_cpp: true, version: None })
    }

    pub fn new_c() -> Result<Self> {
        let mut parser = Parser::new();
        let lang = tree_sitter_c::language();
        parser.set_language(lang).context("Failed to set C language")?;
        Ok(Self { parser, is_cpp: false, version: None })
    }
    
    pub fn new_with_version(is_cpp: bool, version: Version) -> Result<Self> {
        let mut parser = Parser::new();
        if is_cpp {
            let lang = tree_sitter_cpp::language();
            parser.set_language(lang).context("Failed to set C++ language")?;
        } else {
            let lang = tree_sitter_c::language();
            parser.set_language(lang).context("Failed to set C language")?;
        }
        Ok(Self { parser, is_cpp, version: Some(version) })
    }

    pub fn parse(
        &mut self,
        file_path: &str,
        content: &str,
    ) -> Result<(Vec<SymbolIR>, Vec<EdgeIR>, Vec<OccurrenceIR>)> {
        // Detect version if not already specified
        if self.version.is_none() {
            let path = Path::new(file_path);
            self.version = Some(CppVersionDetector::detect(path, content));
        }
        
        let tree = self.parser.parse(content, None)
            .context("Failed to parse file")?;

        let root_node = tree.root_node();
        
        let mut symbols = Vec::new();
        let mut edges = Vec::new();
        let mut occurrences = Vec::new();
        
        let mut context = ParseContext::new();
        
        self.walk_node(
            root_node,
            content,
            file_path,
            &mut symbols,
            &mut edges,
            &mut occurrences,
            &mut context,
        )?;
        
        Ok((symbols, edges, occurrences))
    }

    fn walk_node(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        match node.kind() {
            "function_definition" => {
                self.handle_function(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "class_specifier" if self.is_cpp => {
                self.handle_class(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "struct_specifier" => {
                self.handle_struct(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "union_specifier" => {
                self.handle_union(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "enum_specifier" => {
                self.handle_enum(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "namespace_definition" if self.is_cpp => {
                self.handle_namespace(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "alias_declaration" if self.is_cpp => {
                self.handle_alias_declaration(node, content, file_path, symbols, occurrences, context)?;
            }
            "using_declaration" if self.is_cpp => {
                self.handle_using_declaration(node, content, file_path, symbols, occurrences, context)?;
            }
            "declaration" => {
                // Handle global variables, typedefs, function declarations etc.
                self.handle_declaration(node, content, file_path, symbols, edges, occurrences, context)?;
            }
            "preproc_include" => {
                self.handle_include(node, content, file_path, edges)?;
            }
            "preproc_def" | "preproc_function_def" => {
                self.handle_macro_definition(node, content, file_path, symbols, occurrences)?;
            }
            "lambda_expression" => {
                self.handle_lambda(node, content, file_path, symbols, occurrences, context)?;
            }
            _ => {
                // Recursively walk children
                for child in node.children(&mut node.walk()) {
                    self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
                }
            }
        }
        Ok(())
    }

    fn handle_function(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        // Get function declarator
        let declarator = node.child_by_field_name("declarator")
            .context("Function without declarator")?;
        
        // Check if this is a friend function
        let is_friend = node.children(&mut node.walk())
            .any(|child| child.kind() == "friend" || self.get_text(child, content) == "friend");
        
        let name = if is_friend {
            // For friend functions, be more lenient
            self.get_function_name(declarator, content)
                .unwrap_or_else(|_| {
                    // Fallback for friend operator functions
                    for child in declarator.children(&mut declarator.walk()) {
                        if child.kind() == "operator_name" {
                            return self.normalize_operator_name(&self.get_text(child, content));
                        } else if child.kind() == "identifier" {
                            return self.get_text(child, content);
                        }
                    }
                    "unknown_friend".to_string()
                })
        } else {
            self.get_function_name(declarator, content)?
        };
        
        // Check if this is a constructor or destructor
        let current_class = context.classes.last();
        let is_constructor = current_class
            .map(|class_name| name == *class_name)
            .unwrap_or(false);
        
        let is_destructor = current_class
            .map(|class_name| name == format!("~{}", class_name))
            .unwrap_or(false) || name.starts_with('~');
        
        let (kind, return_type) = if is_constructor || is_destructor {
            (SymbolKind::Method, String::new())
        } else if current_class.is_some() {
            // Method in class
            let return_type = node.child_by_field_name("type")
                .map(|n| self.get_text(n, content))
                .unwrap_or_else(|| "void".to_string());
            (SymbolKind::Method, return_type)
        } else {
            // Regular function
            let return_type = node.child_by_field_name("type")
                .map(|n| self.get_text(n, content))
                .unwrap_or_else(|| "void".to_string());
            (SymbolKind::Function, return_type)
        };
        
        let fqn = context.build_fqn(&name);
        let sig_hash = format!("{:x}", md5::compute(&fqn));
        
        let params = self.get_function_params(declarator, content);
        
        // Check for virtual, override, and final specifiers
        let mut is_virtual = false;
        let mut is_override = false;
        let mut is_final = false;
        let mut is_pure_virtual = false;
        
        // Check for virtual specifier
        for child in node.children(&mut node.walk()) {
            if child.kind() == "virtual_specifier" || child.kind() == "virtual" {
                let text = self.get_text(child, content);
                if text == "virtual" {
                    is_virtual = true;
                } else if text == "override" {
                    is_override = true;
                } else if text == "final" {
                    is_final = true;
                }
            }
            // Check for pure virtual (= 0)
            if child.kind() == "pure_virtual_specifier" || 
               (child.kind() == "=" && node.child(child.id() + 1).map(|n| self.get_text(n, content) == "0").unwrap_or(false)) {
                is_pure_virtual = true;
                is_virtual = true;
            }
        }
        
        // Build signature with template parameters and specifiers
        let mut signature = String::new();
        
        // Check for template parameters
        let template_params = self.get_template_parameters(node, content);
        if !template_params.is_empty() {
            signature.push_str("template<");
            signature.push_str(&template_params.join(", "));
            signature.push_str("> ");
        }
        
        if is_virtual && !is_override {
            signature.push_str("virtual ");
        }
        
        if is_constructor {
            signature.push_str(&format!("{}({})", name, params.join(", ")));
        } else if is_destructor {
            signature.push_str(&format!("{}()", name));
        } else {
            signature.push_str(&format!("{} {}({})", return_type, name, params.join(", ")));
        }
        
        if is_override {
            signature.push_str(" override");
        }
        if is_final {
            signature.push_str(" final");
        }
        if is_pure_virtual {
            signature.push_str(" = 0");
        }
        
        let symbol = SymbolIR {
            id: format!("{}#{}", file_path, fqn),
            lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
            kind,
            name: name.clone(),
            fqn: fqn.clone(),
            signature: Some(signature),
            file_path: file_path.to_string(),
            span: self.node_to_span(declarator),
            visibility: context.current_access.clone(),
            doc: self.get_preceding_comment(node, content),
            sig_hash,
        };
        
        symbols.push(symbol.clone());
        
        // Add occurrence for definition
        occurrences.push(OccurrenceIR {
            file_path: file_path.to_string(),
            symbol_id: Some(symbol.id.clone()),
            role: OccurrenceRole::Definition,
            span: self.node_to_span(declarator),
            token: name.clone(),
        });
        
        // Process function body for references
        if let Some(body) = node.child_by_field_name("body") {
            self.process_function_body(body, content, file_path, edges, occurrences, &symbol.id)?;
        }
        
        Ok(())
    }

    fn handle_class(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        let name_node = node.child_by_field_name("name")
            .context("Class without name")?;
        let name = self.get_text(name_node, content);
        
        let fqn = context.build_fqn(&name);
        let sig_hash = format!("{:x}", md5::compute(&fqn));
        
        // Build signature with template parameters
        let mut signature = String::new();
        let template_params = self.get_template_parameters(node, content);
        if !template_params.is_empty() {
            signature.push_str("template<");
            signature.push_str(&template_params.join(", "));
            signature.push_str("> class ");
            signature.push_str(&name);
        }
        
        let symbol = SymbolIR {
            id: format!("{}#{}", file_path, fqn),
            lang: ProtoLanguage::Cpp,
            kind: SymbolKind::Class,
            name: name.clone(),
            fqn: fqn.clone(),
            signature: if signature.is_empty() { None } else { Some(signature) },
            file_path: file_path.to_string(),
            span: self.node_to_span(name_node),
            visibility: None,
            doc: None,
            sig_hash,
        };
        
        symbols.push(symbol.clone());
        
        occurrences.push(OccurrenceIR {
            file_path: file_path.to_string(),
            symbol_id: Some(symbol.id.clone()),
            role: OccurrenceRole::Definition,
            span: self.node_to_span(name_node),
            token: name.clone(),
        });
        
        // Handle base classes - base_class_clause is a direct child
        for i in 0..node.child_count() {
            if let Some(child) = node.child(i) {
                if child.kind() == "base_class_clause" {
                    // Process all base classes (handles multiple inheritance)
                    // Walk through all children recursively to find type identifiers
                    let mut stack = vec![child];
                    while let Some(current) = stack.pop() {
                        for j in 0..current.child_count() {
                            if let Some(subchild) = current.child(j) {
                                match subchild.kind() {
                                    "type_identifier" | "qualified_identifier" => {
                                        let base_name = self.get_text(subchild, content);
                                        // Skip access specifiers like "public", "private", "protected"
                                        if base_name != "public" && base_name != "private" && base_name != "protected" && base_name != "virtual" {
                                            edges.push(EdgeIR {
                                                edge_type: EdgeType::Extends,
                                                src: Some(symbol.id.clone()),
                                                dst: Some(base_name),
                                                file_src: Some(file_path.to_string()),
                                                file_dst: None,
                                                resolution: Resolution::Syntactic,
                                                meta: HashMap::new(),
                                                provenance: HashMap::new(),
                                            });
                                        }
                                    }
                                    _ => {
                                        // Push child to stack to process its children
                                        stack.push(subchild);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Process class body
        context.push_class(name.clone());
        if let Some(body) = node.child_by_field_name("body") {
            for child in body.children(&mut body.walk()) {
                match child.kind() {
                    "function_definition" => {
                        self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
                    }
                    "declaration" => {
                        self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
                    }
                    "field_declaration" => {
                        // Check if it's actually a nested class declaration
                        let mut is_class_decl = false;
                        for grandchild in child.children(&mut child.walk()) {
                            if grandchild.kind() == "class_specifier" || grandchild.kind() == "struct_specifier" {
                                is_class_decl = true;
                                self.walk_node(grandchild, content, file_path, symbols, edges, occurrences, context)?;
                                break;
                            }
                        }
                        if !is_class_decl {
                            // Handle class fields/member variables
                            self.handle_field_declaration(child, content, file_path, symbols, occurrences, context)?;
                        }
                    }
                    "access_specifier" => {
                        // Track public/private/protected sections
                        let access = self.get_text(child, content);
                        context.set_access(&access);
                    }
                    _ => {
                        // Walk any other nodes to handle nested classes, etc
                        self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
                    }
                }
            }
        }
        context.pop_class();
        
        Ok(())
    }

    fn handle_struct(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        let name = if let Some(name_node) = node.child_by_field_name("name") {
            let name = self.get_text(name_node, content);
            let fqn = context.build_fqn(&name);
            let sig_hash = format!("{:x}", md5::compute(&fqn));
            
            let symbol = SymbolIR {
                id: format!("{}#{}", file_path, fqn),
                lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                kind: SymbolKind::Struct,
                name: name.clone(),
                fqn: fqn.clone(),
                signature: None,
                file_path: file_path.to_string(),
                span: self.node_to_span(name_node),
                visibility: None,
                doc: None,
                sig_hash,
            };
            
            symbols.push(symbol.clone());
            
            occurrences.push(OccurrenceIR {
                file_path: file_path.to_string(),
                symbol_id: Some(symbol.id.clone()),
                role: OccurrenceRole::Definition,
                span: self.node_to_span(name_node),
                token: name.clone(),
            });
            
            name
        } else {
            return Ok(());
        };
        
        // Process struct body (similar to class)
        context.push_class(name.clone());
        context.set_access("public"); // Structs are public by default
        
        if let Some(body) = node.child_by_field_name("body") {
            for child in body.children(&mut body.walk()) {
                match child.kind() {
                    "function_definition" => {
                        self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
                    }
                    "declaration" => {
                        self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
                    }
                    "field_declaration" => {
                        self.handle_field_declaration(child, content, file_path, symbols, occurrences, context)?;
                    }
                    "access_specifier" if self.is_cpp => {
                        let access = self.get_text(child, content);
                        context.set_access(&access);
                    }
                    _ => {}
                }
            }
        }
        context.pop_class();
        
        Ok(())
    }

    fn handle_union(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        let name = if let Some(name_node) = node.child_by_field_name("name") {
            let name = self.get_text(name_node, content);
            let fqn = context.build_fqn(&name);
            let sig_hash = format!("{:x}", md5::compute(&fqn));
            
            let symbol = SymbolIR {
                id: format!("{}#{}", file_path, fqn),
                lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                kind: SymbolKind::Union,
                name: name.clone(),
                fqn: fqn.clone(),
                signature: None,
                file_path: file_path.to_string(),
                span: self.node_to_span(name_node),
                visibility: None,
                doc: None,
                sig_hash,
            };
            
            symbols.push(symbol.clone());
            
            occurrences.push(OccurrenceIR {
                file_path: file_path.to_string(),
                symbol_id: Some(symbol.id.clone()),
                role: OccurrenceRole::Definition,
                span: self.node_to_span(name_node),
                token: name.clone(),
            });
            
            name
        } else {
            return Ok(());
        };
        
        // Process union body
        context.push_class(name.clone());
        context.set_access("public"); // Union members are public by default
        
        if let Some(body) = node.child_by_field_name("body") {
            for child in body.children(&mut body.walk()) {
                if child.kind() == "field_declaration" {
                    self.handle_field_declaration(child, content, file_path, symbols, occurrences, context)?;
                }
            }
        }
        context.pop_class();
        
        Ok(())
    }

    fn handle_enum(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        _edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        if let Some(name_node) = node.child_by_field_name("name") {
            let name = self.get_text(name_node, content);
            let fqn = context.build_fqn(&name);
            let sig_hash = format!("{:x}", md5::compute(&fqn));
            
            let symbol = SymbolIR {
                id: format!("{}#{}", file_path, fqn),
                lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                kind: SymbolKind::Enum,
                name: name.clone(),
                fqn: fqn.clone(),
                signature: None,
                file_path: file_path.to_string(),
                span: self.node_to_span(name_node),
                visibility: None,
                doc: None,
                sig_hash,
            };
            
            symbols.push(symbol.clone());
            
            occurrences.push(OccurrenceIR {
                file_path: file_path.to_string(),
                symbol_id: Some(symbol.id.clone()),
                role: OccurrenceRole::Definition,
                span: self.node_to_span(name_node),
                token: name.clone(),
            });
            
            // Process enum values
            if let Some(body) = node.child_by_field_name("body") {
                for child in body.children(&mut body.walk()) {
                    if child.kind() == "enumerator" {
                        if let Some(enum_val_node) = child.child_by_field_name("name") {
                            let enum_val = self.get_text(enum_val_node, content);
                            let enum_fqn = format!("{}.{}", fqn, enum_val);
                            let enum_sig_hash = format!("{:x}", md5::compute(&enum_fqn));
                            
                            let enum_symbol = SymbolIR {
                                id: format!("{}#{}", file_path, enum_fqn),
                                lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                                kind: SymbolKind::EnumMember,
                                name: enum_val.clone(),
                                fqn: enum_fqn,
                                signature: None,
                                file_path: file_path.to_string(),
                                span: self.node_to_span(enum_val_node),
                                visibility: None,
                                doc: None,
                                sig_hash: enum_sig_hash,
                            };
                            
                            symbols.push(enum_symbol.clone());
                            
                            occurrences.push(OccurrenceIR {
                                file_path: file_path.to_string(),
                                symbol_id: Some(enum_symbol.id),
                                role: OccurrenceRole::Definition,
                                span: self.node_to_span(enum_val_node),
                                token: enum_val,
                            });
                        }
                    }
                }
            }
        }
        
        Ok(())
    }

    fn handle_alias_declaration(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        // using alias = type;
        if let Some(name_node) = node.child_by_field_name("name") {
            let name = self.get_text(name_node, content);
            let fqn = context.build_fqn(&name);
            let sig_hash = format!("{:x}", md5::compute(&fqn));
            
            // Get the aliased type
            let aliased_type = if let Some(type_node) = node.child_by_field_name("type") {
                self.get_text(type_node, content)
            } else {
                "unknown".to_string()
            };
            
            let symbol = SymbolIR {
                id: format!("{}#{}", file_path, fqn),
                lang: ProtoLanguage::Cpp,
                kind: SymbolKind::TypeAlias,
                name: name.clone(),
                fqn: fqn.clone(),
                signature: Some(format!("using {} = {}", name, aliased_type)),
                file_path: file_path.to_string(),
                span: self.node_to_span(name_node),
                visibility: context.current_access.clone(),
                doc: None,
                sig_hash,
            };
            
            symbols.push(symbol.clone());
            
            occurrences.push(OccurrenceIR {
                file_path: file_path.to_string(),
                symbol_id: Some(symbol.id),
                role: OccurrenceRole::Definition,
                span: self.node_to_span(name_node),
                token: name,
            });
        }
        
        Ok(())
    }
    
    fn handle_using_declaration(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        // using namespace::name; or using typename Base::type;
        // For now, just track it as a using declaration
        let full_text = self.get_text(node, content);
        
        // Try to extract the name being imported
        for child in node.children(&mut node.walk()) {
            if child.kind() == "qualified_identifier" || child.kind() == "identifier" {
                let name = self.get_text(child, content);
                
                // Create a reference occurrence for the imported symbol
                occurrences.push(OccurrenceIR {
                    file_path: file_path.to_string(),
                    symbol_id: Some(name.clone()),
                    role: OccurrenceRole::Reference,
                    span: self.node_to_span(child),
                    token: name,
                });
                break;
            }
        }
        
        Ok(())
    }
    
    fn handle_namespace(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        let (name, name_node) = if let Some(name_node) = node.child_by_field_name("name") {
            (self.get_text(name_node, content), Some(name_node))
        } else {
            // Anonymous namespace
            ("<anonymous>".to_string(), None)
        };
        
        // Create namespace symbol
        let fqn = context.build_fqn(&name);
        let sig_hash = format!("{:x}", md5::compute(&fqn));
        
        let symbol = SymbolIR {
            id: format!("{}#{}", file_path, fqn),
            lang: ProtoLanguage::Cpp,
            kind: SymbolKind::Namespace,
            name: name.clone(),
            fqn: fqn.clone(),
            signature: None,
            file_path: file_path.to_string(),
            span: if let Some(n) = name_node {
                self.node_to_span(n)
            } else {
                self.node_to_span(node)
            },
            visibility: None,
            doc: None,
            sig_hash,
        };
        
        symbols.push(symbol.clone());
        
        // Add occurrence for namespace definition
        occurrences.push(OccurrenceIR {
            file_path: file_path.to_string(),
            symbol_id: Some(symbol.id),
            role: OccurrenceRole::Definition,
            span: if let Some(n) = name_node {
                self.node_to_span(n)
            } else {
                self.node_to_span(node)
            },
            token: name.clone(),
        });
        
        context.push_namespace(name.clone());
        
        // Process namespace body
        if let Some(body) = node.child_by_field_name("body") {
            for child in body.children(&mut body.walk()) {
                self.walk_node(child, content, file_path, symbols, edges, occurrences, context)?;
            }
        }
        
        context.pop_namespace();
        Ok(())
    }

    fn handle_declaration(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        _edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        // Check for typedef
        let mut is_typedef = false;
        for child in node.children(&mut node.walk()) {
            if child.kind() == "storage_class_specifier" {
                let text = self.get_text(child, content);
                if text == "typedef" {
                    is_typedef = true;
                    break;
                }
            }
        }
        
        if is_typedef {
            // Handle typedef declaration
            if let Some(declarator) = node.child_by_field_name("declarator") {
                let name = self.extract_declarator_name(declarator, content);
                if let Some(name) = name {
                    let fqn = context.build_fqn(&name);
                    let sig_hash = format!("{:x}", md5::compute(&fqn));
                    
                    // Get the type being aliased
                    let aliased_type = if let Some(type_node) = node.child_by_field_name("type") {
                        self.get_text(type_node, content)
                    } else {
                        "unknown".to_string()
                    };
                    
                    let symbol = SymbolIR {
                        id: format!("{}#{}", file_path, fqn),
                        lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                        kind: SymbolKind::Typedef,
                        name: name.clone(),
                        fqn: fqn.clone(),
                        signature: Some(format!("typedef {} {}", aliased_type, name)),
                        file_path: file_path.to_string(),
                        span: self.node_to_span(declarator),
                        visibility: context.current_access.clone(),
                        doc: None,
                        sig_hash,
                    };
                    
                    symbols.push(symbol.clone());
                    
                    occurrences.push(OccurrenceIR {
                        file_path: file_path.to_string(),
                        symbol_id: Some(symbol.id),
                        role: OccurrenceRole::Definition,
                        span: self.node_to_span(declarator),
                        token: name,
                    });
                    
                    return Ok(());
                }
            }
        }
        
        // Check if this is a friend declaration
        let is_friend = node.children(&mut node.walk())
            .any(|child| child.kind() == "friend" || self.get_text(child, content) == "friend");
        
        // Check if this is a function declaration (prototype)
        if let Some(declarator) = node.child_by_field_name("declarator") {
            if declarator.kind() == "function_declarator" {
                // This is a function declaration
                // For friend declarations, be more lenient with name extraction
                let name = if is_friend {
                    // Try to extract name from friend declaration
                    self.get_function_name(declarator, content)
                        .unwrap_or_else(|_| {
                            // Fallback: try to find operator_name or identifier
                            for child in declarator.children(&mut declarator.walk()) {
                                if child.kind() == "operator_name" {
                                    return self.normalize_operator_name(&self.get_text(child, content));
                                } else if child.kind() == "identifier" {
                                    return self.get_text(child, content);
                                }
                            }
                            "unknown_friend".to_string()
                        })
                } else {
                    self.get_function_name(declarator, content)?
                };
                let return_type = node.child_by_field_name("type")
                    .map(|n| self.get_text(n, content))
                    .unwrap_or_else(|| "void".to_string());
                
                let fqn = context.build_fqn(&name);
                let sig_hash = format!("{:x}", md5::compute(&fqn));
                
                let params = self.get_function_params(declarator, content);
                let signature = if is_friend {
                    format!("friend {} {}({})", return_type, name, params.join(", "))
                } else {
                    format!("{} {}({})", return_type, name, params.join(", "))
                };
                
                let symbol = SymbolIR {
                    id: format!("{}#{}", file_path, fqn),
                    lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                    kind: SymbolKind::Function,
                    name: name.clone(),
                    fqn: fqn.clone(),
                    signature: Some(signature),
                    file_path: file_path.to_string(),
                    span: self.node_to_span(declarator),
                    visibility: context.current_access.clone(),
                    doc: None,
                    sig_hash,
                };
                
                symbols.push(symbol.clone());
                
                occurrences.push(OccurrenceIR {
                    file_path: file_path.to_string(),
                    symbol_id: Some(symbol.id),
                    role: OccurrenceRole::Definition,
                    span: self.node_to_span(declarator),
                    token: name,
                });
                
                return Ok(());
            }
        }
        
        // Handle variable declarations, typedefs, etc.
        for child in node.children(&mut node.walk()) {
            if child.kind() == "init_declarator" {
                if let Some(declarator) = child.child_by_field_name("declarator") {
                    if let Some(name) = self.extract_identifier(declarator, content) {
                        let fqn = context.build_fqn(&name);
                        let sig_hash = format!("{:x}", md5::compute(&fqn));
                        
                        let symbol = SymbolIR {
                            id: format!("{}#{}", file_path, fqn),
                            lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                            kind: SymbolKind::Variable,
                            name: name.clone(),
                            fqn: fqn.clone(),
                            signature: None,
                            file_path: file_path.to_string(),
                            span: self.node_to_span(declarator),
                            visibility: context.current_access.clone(),
                            doc: None,
                            sig_hash,
                        };
                        
                        symbols.push(symbol.clone());
                        
                        occurrences.push(OccurrenceIR {
                            file_path: file_path.to_string(),
                            symbol_id: Some(symbol.id),
                            role: OccurrenceRole::Definition,
                            span: self.node_to_span(declarator),
                            token: name,
                        });
                    }
                }
            }
        }
        
        Ok(())
    }

    fn handle_field_declaration(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        // Get the type for all fields in this declaration
        let field_type = node.child_by_field_name("type")
            .map(|n| self.get_text(n, content))
            .unwrap_or_else(|| "unknown".to_string());
        
        // Handle multiple declarators (e.g., "int x, y, z;")
        let mut declarators = Vec::new();
        
        // Check all children for field_identifier nodes (for comma-separated fields)
        for child in node.children(&mut node.walk()) {
            match child.kind() {
                "field_identifier" => {
                    // Direct field identifier
                    declarators.push(child);
                }
                "init_declarator" => {
                    // Field with possible initializer
                    if let Some(decl) = child.child_by_field_name("declarator") {
                        declarators.push(decl);
                    }
                }
                _ => {}
            }
        }
        
        // If we didn't find any declarators via children, check the declarator field
        if declarators.is_empty() {
            if let Some(declarator) = node.child_by_field_name("declarator") {
                declarators.push(declarator);
            }
        }
        
        // Process each declarator
        for declarator in declarators {
            // Check if this is a function declarator (method declaration)
            // Function declarators have a "parameters" field
            // BUT: Function pointer fields like void (*field)(params) also have parameters
            // We need to distinguish them
            let mut is_function = false;
            if declarator.kind() == "function_declarator" {
                // Check if it's a function pointer by looking for parenthesized_declarator
                if let Some(inner_decl) = declarator.child_by_field_name("declarator") {
                    is_function = inner_decl.kind() != "parenthesized_declarator";
                } else {
                    is_function = true;
                }
            }
            
            if is_function {
                // This is a method declaration, not a field
                // Handle it as a function/method declaration
                self.handle_function(node, content, file_path, symbols, &mut Vec::new(), occurrences, context)?;
            } else {
                // This is an actual field
                let name = if let Some(extracted) = self.extract_declarator_name(declarator, content) {
                    extracted
                } else {
                    self.get_text(declarator, content)
                };
                
                let fqn = context.build_fqn(&name);
                let sig_hash = format!("{:x}", md5::compute(&fqn));
                
                
                let symbol = SymbolIR {
                    id: format!("{}#{}", file_path, fqn),
                    lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                    kind: SymbolKind::Field,
                    name: name.clone(),
                    fqn: fqn.clone(),
                    signature: Some(format!("{} {}", field_type, name)),
                    file_path: file_path.to_string(),
                    span: self.node_to_span(declarator),
                    visibility: context.current_access.clone(),
                    doc: None,
                    sig_hash,
                };
                
                symbols.push(symbol.clone());
                
                occurrences.push(OccurrenceIR {
                    file_path: file_path.to_string(),
                    symbol_id: Some(symbol.id),
                    role: OccurrenceRole::Definition,
                    span: self.node_to_span(declarator),
                    token: name,
                });
            }
        }
        
        Ok(())
    }

    fn handle_include(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        edges: &mut Vec<EdgeIR>,
    ) -> Result<()> {
        if let Some(path_node) = node.child_by_field_name("path") {
            let include_path = self.get_text(path_node, content)
                .trim_matches(|c| c == '"' || c == '<' || c == '>')
                .to_string();
            
            edges.push(EdgeIR {
                edge_type: EdgeType::Imports,
                src: Some(file_path.to_string()),
                dst: Some(include_path),
                file_src: Some(file_path.to_string()),
                file_dst: None,
                resolution: Resolution::Syntactic,
                meta: HashMap::new(),
                provenance: HashMap::new(),
            });
        }
        
        Ok(())
    }
    
    fn handle_macro_definition(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        occurrences: &mut Vec<OccurrenceIR>,
    ) -> Result<()> {
        // Get the macro name
        if let Some(name_node) = node.child_by_field_name("name") {
            let name = self.get_text(name_node, content);
            let fqn = name.clone(); // Macros are global
            let sig_hash = format!("{:x}", md5::compute(&fqn));
            
            // Check if it's a function-like macro
            let is_function_macro = node.kind() == "preproc_function_def";
            
            // Build signature
            let mut signature = String::new();
            if is_function_macro {
                signature.push_str("#define ");
                signature.push_str(&name);
                // Get parameters if any
                if let Some(params_node) = node.child_by_field_name("parameters") {
                    let params_text = self.get_text(params_node, content);
                    signature.push_str(&params_text);
                }
                signature.push_str(" ...");
            } else {
                signature.push_str("#define ");
                signature.push_str(&name);
                // Get the value if present
                if let Some(value_node) = node.child_by_field_name("value") {
                    let value = self.get_text(value_node, content);
                    if !value.is_empty() {
                        signature.push(' ');
                        signature.push_str(value.trim());
                    }
                }
            }
            
            let symbol = SymbolIR {
                id: format!("{}#{}", file_path, fqn),
                lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
                kind: SymbolKind::Constant, // Macros are like constants
                name: name.clone(),
                fqn,
                signature: Some(signature),
                file_path: file_path.to_string(),
                span: self.node_to_span(name_node),
                visibility: None, // Macros don't have visibility modifiers
                doc: self.get_preceding_comment(node, content),
                sig_hash,
            };
            
            symbols.push(symbol.clone());
            
            occurrences.push(OccurrenceIR {
                file_path: file_path.to_string(),
                symbol_id: Some(symbol.id),
                role: OccurrenceRole::Definition,
                span: self.node_to_span(name_node),
                token: name,
            });
        }
        
        Ok(())
    }

    fn process_function_body(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        edges: &mut Vec<EdgeIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        caller_id: &str,
    ) -> Result<()> {
        // Walk through the function body looking for function calls
        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            if child.kind() == "call_expression" {
                if let Some(func_node) = child.child_by_field_name("function") {
                    if let Some(name) = self.extract_identifier(func_node, content) {
                        // Add call edge
                        edges.push(EdgeIR {
                            edge_type: EdgeType::Calls,
                            src: Some(caller_id.to_string()),
                            dst: Some(name.clone()),
                            file_src: Some(file_path.to_string()),
                            file_dst: None,
                            resolution: Resolution::Syntactic,
                            meta: HashMap::new(),
                            provenance: HashMap::new(),
                        });
                        
                        // Add reference occurrence
                        occurrences.push(OccurrenceIR {
                            file_path: file_path.to_string(),
                            symbol_id: None, // Will be resolved later
                            role: OccurrenceRole::Reference,
                            span: self.node_to_span(func_node),
                            token: name,
                        });
                    }
                }
            }
            
            // Recursively process nested blocks
            self.process_function_body(child, content, file_path, edges, occurrences, caller_id)?;
        }
        
        Ok(())
    }

    fn extract_declarator_name(&self, declarator: Node, content: &str) -> Option<String> {
        // Similar to get_function_name but returns Option
        let mut current = declarator;
        loop {
            match current.kind() {
                "function_declarator" | "array_declarator" => {
                    if let Some(decl) = current.child_by_field_name("declarator") {
                        current = decl;
                    } else {
                        break;
                    }
                }
                "parenthesized_declarator" => {
                    // For function pointers, the identifier might be inside the parentheses
                    if let Some(decl) = current.child_by_field_name("declarator") {
                        current = decl;
                    } else {
                        // Check all children for an identifier
                        for i in 0..current.child_count() {
                            if let Some(child) = current.child(i) {
                                if child.kind() == "identifier" {
                                    return Some(self.get_text(child, content));
                                }
                            }
                        }
                        break;
                    }
                }
                "pointer_declarator" | "reference_declarator" => {
                    // Check if we have a function_declarator child (not necessarily in declarator field)
                    let mut found_function = false;
                    for i in 0..current.child_count() {
                        if let Some(child) = current.child(i) {
                            if child.kind() == "function_declarator" {
                                current = child;
                                found_function = true;
                                break;
                            }
                        }
                    }
                    
                    if !found_function {
                        if let Some(decl) = current.child_by_field_name("declarator") {
                            current = decl;
                        } else {
                            break;
                        }
                    }
                }
                "identifier" => {
                    return Some(self.get_text(current, content));
                }
                "field_identifier" => {
                    return Some(self.get_text(current, content));
                }
                "destructor_name" => {
                    return Some(self.get_text(current, content));
                }
                "operator_name" => {
                    let op_text = self.get_text(current, content);
                    return Some(self.normalize_operator_name(&op_text));
                }
                "abstract_pointer_declarator" | "abstract_function_declarator" | "abstract_array_declarator" => {
                    // Abstract declarators don't have names - skip them
                    return None;
                }
                _ => break,
            }
        }
        None
    }
    
    fn get_function_name(&self, declarator: Node, content: &str) -> Result<String> {
        // Handle different declarator types (pointer, reference, etc.)
        let mut current = declarator;
        
        // First pass: follow declarator chain
        loop {
            match current.kind() {
                "function_declarator" => {
                    // For function declarator, first check if it directly contains operator_name
                    for i in 0..current.child_count() {
                        if let Some(child) = current.child(i) {
                            if child.kind() == "operator_name" {
                                let op_text = self.get_text(child, content);
                                return Ok(self.normalize_operator_name(&op_text));
                            }
                        }
                    }
                    // Otherwise follow the declarator chain
                    if let Some(decl) = current.child_by_field_name("declarator") {
                        current = decl;
                    } else {
                        break;
                    }
                }
                "pointer_declarator" | "reference_declarator" => {
                    // Check if we have a function_declarator child (not necessarily in declarator field)
                    let mut found_function = false;
                    for i in 0..current.child_count() {
                        if let Some(child) = current.child(i) {
                            if child.kind() == "function_declarator" {
                                current = child;
                                found_function = true;
                                break;
                            }
                        }
                    }
                    
                    if !found_function {
                        if let Some(decl) = current.child_by_field_name("declarator") {
                            current = decl;
                        } else {
                            break;
                        }
                    }
                }
                "identifier" => {
                    return Ok(self.get_text(current, content));
                }
                "field_identifier" => {
                    return Ok(self.get_text(current, content));
                }
                "destructor_name" => {
                    return Ok(self.get_text(current, content));
                }
                "qualified_identifier" => {
                    // Handle qualified operators like std::operator<<
                    let text = self.get_text(current, content);
                    if text.contains("operator") {
                        return Ok(self.normalize_operator_name(&text));
                    }
                    return Ok(text);
                }
                "operator_name" => {
                    let op_text = self.get_text(current, content);
                    return Ok(self.normalize_operator_name(&op_text));
                }
                _ => {
                    // For unknown node types, check all children for operator_name
                    for i in 0..current.child_count() {
                        if let Some(child) = current.child(i) {
                            if child.kind() == "operator_name" {
                                let op_text = self.get_text(child, content);
                                return Ok(self.normalize_operator_name(&op_text));
                            }
                        }
                    }
                    break;
                }
            }
        }
        
        Err(anyhow::anyhow!("Could not extract function name"))
    }

    fn get_function_params(&self, declarator: Node, content: &str) -> Vec<String> {
        let mut params = Vec::new();
        
        // Find the function_declarator node
        let mut func_decl = None;
        let mut current = declarator;
        loop {
            if current.kind() == "function_declarator" {
                func_decl = Some(current);
                break;
            }
            if let Some(child) = current.child_by_field_name("declarator") {
                current = child;
            } else {
                break;
            }
        }
        
        if let Some(func) = func_decl {
            if let Some(param_list) = func.child_by_field_name("parameters") {
                for child in param_list.children(&mut param_list.walk()) {
                    if child.kind() == "parameter_declaration" {
                        let param_text = self.get_text(child, content);
                        params.push(param_text);
                    }
                }
            }
        }
        
        params
    }

    fn extract_identifier(&self, node: Node, content: &str) -> Option<String> {
        match node.kind() {
            "identifier" | "field_identifier" => Some(self.get_text(node, content)),
            "qualified_identifier" => Some(self.get_text(node, content)),
            _ => {
                // Try to find an identifier child
                for child in node.children(&mut node.walk()) {
                    if let Some(id) = self.extract_identifier(child, content) {
                        return Some(id);
                    }
                }
                None
            }
        }
    }

    fn handle_lambda(
        &self,
        node: Node,
        content: &str,
        file_path: &str,
        symbols: &mut Vec<SymbolIR>,
        occurrences: &mut Vec<OccurrenceIR>,
        context: &mut ParseContext,
    ) -> Result<()> {
        // Create a unique ID for the lambda
        let lambda_id = format!("lambda_{}_{}",
            node.start_position().row,
            node.start_position().column);
        let fqn = context.build_fqn(&lambda_id);
        let sig_hash = format!("{:x}", md5::compute(&fqn));
        
        // Build signature from captures and parameters
        let mut signature = String::new();
        
        // Handle capture clause [&] or [=] or [this] etc
        if let Some(captures) = node.child_by_field_name("captures") {
            let capture_text = self.get_text(captures, content);
            signature.push_str(&capture_text);
        }
        
        // Handle parameters
        signature.push('(');
        if let Some(params) = node.child_by_field_name("declarator") {
            if let Some(params_list) = params.child_by_field_name("parameters") {
                let mut param_strs = Vec::new();
                for child in params_list.children(&mut params_list.walk()) {
                    if child.kind() == "parameter_declaration" {
                        param_strs.push(self.get_text(child, content));
                    }
                }
                signature.push_str(&param_strs.join(", "));
            }
        }
        signature.push_str(") {...}");
        
        let symbol = SymbolIR {
            id: format!("{}#{}", file_path, fqn),
            lang: if self.is_cpp { ProtoLanguage::Cpp } else { ProtoLanguage::C },
            kind: SymbolKind::Function, // Lambdas are anonymous functions
            name: lambda_id.clone(),
            fqn,
            signature: Some(signature),
            file_path: file_path.to_string(),
            span: self.node_to_span(node),
            visibility: None,
            doc: None,
            sig_hash,
        };
        
        symbols.push(symbol.clone());
        
        occurrences.push(OccurrenceIR {
            file_path: file_path.to_string(),
            symbol_id: Some(symbol.id),
            role: OccurrenceRole::Definition,
            span: self.node_to_span(node),
            token: lambda_id,
        });
        
        // Walk the body to find any calls or references inside
        if let Some(body) = node.child_by_field_name("body") {
            self.walk_node(body, content, file_path, symbols, &mut Vec::new(), occurrences, context)?;
        }
        
        Ok(())
    }
    
    fn get_template_parameters(&self, node: Node, content: &str) -> Vec<String> {
        let mut params = Vec::new();
        
        // Look for template_declaration parent
        if let Some(parent) = node.parent() {
            if parent.kind() == "template_declaration" {
                if let Some(params_node) = parent.child_by_field_name("parameters") {
                    for child in params_node.children(&mut params_node.walk()) {
                        match child.kind() {
                            "type_parameter_declaration" => {
                                let mut param = String::new();
                                // Check for typename or class keyword
                                for grandchild in child.children(&mut child.walk()) {
                                    if grandchild.kind() == "typename" || grandchild.kind() == "class" {
                                        param.push_str(&self.get_text(grandchild, content));
                                        param.push(' ');
                                    } else if grandchild.kind() == "type_identifier" {
                                        param.push_str(&self.get_text(grandchild, content));
                                    }
                                }
                                if !param.is_empty() {
                                    params.push(param.trim().to_string());
                                }
                            }
                            "variadic_type_parameter_declaration" => {
                                let param = self.get_text(child, content);
                                params.push(param);
                            }
                            "optional_type_parameter_declaration" => {
                                let param = self.get_text(child, content);
                                params.push(param);
                            }
                            _ => {}
                        }
                    }
                }
            }
        }
        
        params
    }
    
    fn normalize_operator_name(&self, op: &str) -> String {
        // Normalize operator names to a consistent format
        // This helps with symbol resolution and matching
        let normalized = op.trim()
            .replace("operator ", "operator")
            .replace("operator\t", "operator")
            .replace("  ", " ");
        
        // Map common operators to standard names
        match normalized.as_str() {
            "operator+" => "operator+".to_string(),
            "operator-" => "operator-".to_string(),
            "operator*" => "operator*".to_string(),
            "operator/" => "operator/".to_string(),
            "operator%" => "operator%".to_string(),
            "operator==" => "operator==".to_string(),
            "operator!=" => "operator!=".to_string(),
            "operator<" => "operator<".to_string(),
            "operator>" => "operator>".to_string(),
            "operator<=" => "operator<=".to_string(),
            "operator>=" => "operator>=".to_string(),
            "operator&&" => "operator&&".to_string(),
            "operator||" => "operator||".to_string(),
            "operator!" => "operator!".to_string(),
            "operator&" => "operator&".to_string(),
            "operator|" => "operator|".to_string(),
            "operator^" => "operator^".to_string(),
            "operator~" => "operator~".to_string(),
            "operator<<" => "operator<<".to_string(),
            "operator>>" => "operator>>".to_string(),
            "operator=" => "operator=".to_string(),
            "operator+=" => "operator+=".to_string(),
            "operator-=" => "operator-=".to_string(),
            "operator*=" => "operator*=".to_string(),
            "operator/=" => "operator/=".to_string(),
            "operator%=" => "operator%=".to_string(),
            "operator&=" => "operator&=".to_string(),
            "operator|=" => "operator|=".to_string(),
            "operator^=" => "operator^=".to_string(),
            "operator<<=" => "operator<<=".to_string(),
            "operator>>=" => "operator>>=".to_string(),
            "operator++" => "operator++".to_string(),
            "operator--" => "operator--".to_string(),
            "operator->" => "operator->".to_string(),
            "operator->*" => "operator->*".to_string(),
            "operator()" => "operator()".to_string(),
            "operator[]" => "operator[]".to_string(),
            "operator new" => "operator new".to_string(),
            "operator new[]" => "operator new[]".to_string(),
            "operator delete" => "operator delete".to_string(),
            "operator delete[]" => "operator delete[]".to_string(),
            "operator," => "operator,".to_string(),
            _ => normalized
        }
    }
    
    fn get_text(&self, node: Node, content: &str) -> String {
        content[node.byte_range()].to_string()
    }
    
    fn get_preceding_comment(&self, node: Node, content: &str) -> Option<String> {
        // Look for a comment immediately before this node
        if let Some(parent) = node.parent() {
            let node_start = node.start_position().row;
            
            // Check siblings before this node
            for i in 0..parent.child_count() {
                if let Some(child) = parent.child(i) {
                    // If we've reached our node, stop
                    if child.id() == node.id() {
                        break;
                    }
                    
                    // Check if this is a comment that ends right before our node
                    if child.kind() == "comment" {
                        let comment_end = child.end_position().row;
                        // Comment should be on the line immediately before or same line
                        if comment_end == node_start || comment_end == node_start - 1 {
                            let comment_text = self.get_text(child, content);
                            // Clean up the comment
                            return Some(self.clean_comment(comment_text));
                        }
                    }
                }
            }
        }
        None
    }
    
    fn clean_comment(&self, comment: String) -> String {
        let comment = comment.trim();
        
        // Remove /** and */ for block comments
        let comment = if comment.starts_with("/**") && comment.ends_with("*/") {
            comment[3..comment.len()-2].trim().to_string()
        } else if comment.starts_with("/*") && comment.ends_with("*/") {
            comment[2..comment.len()-2].trim().to_string()
        } else if comment.starts_with("//") {
            comment[2..].trim().to_string()
        } else {
            comment.to_string()
        };
        
        // Remove leading asterisks from each line (common in Doxygen)
        comment.lines()
            .map(|line| {
                let line = line.trim();
                if line.starts_with("* ") {
                    &line[2..]
                } else if line.starts_with("*") {
                    &line[1..]
                } else {
                    line
                }
            })
            .collect::<Vec<_>>()
            .join("\n")
            .trim()
            .to_string()
    }

    fn node_to_span(&self, node: Node) -> Span {
        let start = node.start_position();
        let end = node.end_position();
        Span {
            start_line: start.row as u32,
            start_col: start.column as u32,
            end_line: end.row as u32,
            end_col: end.column as u32,
        }
    }
}

struct ParseContext {
    namespaces: Vec<String>,
    classes: Vec<String>,
    current_access: Option<String>,
}

impl ParseContext {
    fn new() -> Self {
        Self {
            namespaces: Vec::new(),
            classes: Vec::new(),
            current_access: None,
        }
    }

    fn push_namespace(&mut self, name: String) {
        self.namespaces.push(name);
    }

    fn pop_namespace(&mut self) {
        self.namespaces.pop();
    }

    fn push_class(&mut self, name: String) {
        self.classes.push(name);
        self.current_access = Some("private".to_string()); // Default for C++ classes
    }

    fn pop_class(&mut self) {
        self.classes.pop();
        self.current_access = None;
    }

    fn set_access(&mut self, access: &str) {
        self.current_access = Some(access.trim_end_matches(':').to_string());
    }

    fn build_fqn(&self, name: &str) -> String {
        let mut parts = Vec::new();
        
        // Add namespaces
        for ns in &self.namespaces {
            if ns != "<anonymous>" {
                parts.push(ns.clone());
            }
        }
        
        // Add classes
        for class in &self.classes {
            parts.push(class.clone());
        }
        
        // Add the name itself
        parts.push(name.to_string());
        
        if self.namespaces.is_empty() && self.classes.is_empty() {
            name.to_string()
        } else {
            parts.join("::")
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    #[test]
    fn test_parse_simple_function() -> Result<()> {
        let mut harness = CppHarness::new_c()?;
        let source = r#"
int add(int a, int b) {
    return a + b;
}
"#;
        
        let (symbols, edges, occurrences) = harness.parse("test.c", source)?;
        
        assert_eq!(symbols.len(), 1);
        assert_eq!(symbols[0].name, "add");
        assert_eq!(symbols[0].kind, SymbolKind::Function);
        assert!(symbols[0].signature.as_ref().unwrap().contains("int add(int a, int b)"));
        
        assert_eq!(occurrences.len(), 1);
        assert_eq!(occurrences[0].role, OccurrenceRole::Definition);
        
        Ok(())
    }

    #[test]
    fn test_parse_cpp_class() -> Result<()> {
        let mut harness = CppHarness::new_cpp()?;
        let source = r#"
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }
private:
    int value;
};
"#;
        
        let (symbols, _edges, occurrences) = harness.parse("test.cpp", source)?;
        
        // Should have: Calculator class, add method, value field
        assert_eq!(symbols.len(), 3);
        
        let class_sym = symbols.iter().find(|s| s.name == "Calculator").unwrap();
        assert_eq!(class_sym.kind, SymbolKind::Class);
        
        let method_sym = symbols.iter().find(|s| s.name == "add").unwrap();
        assert_eq!(method_sym.kind, SymbolKind::Method);
        assert_eq!(method_sym.fqn, "Calculator::add");
        
        let field_sym = symbols.iter().find(|s| s.name == "value").unwrap();
        assert_eq!(field_sym.kind, SymbolKind::Field);
        assert_eq!(field_sym.fqn, "Calculator::value");
        
        assert_eq!(occurrences.len(), 3);
        
        Ok(())
    }

    #[test]
    fn test_parse_inheritance() -> Result<()> {
        let mut harness = CppHarness::new_cpp()?;
        let source = r#"
class Base {
public:
    virtual void foo() {}
};

class Derived : public Base {
public:
    void foo() override {}
};
"#;
        
        let (symbols, edges, _occurrences) = harness.parse("test.cpp", source)?;
        
        assert_eq!(symbols.len(), 4); // Base, Base::foo, Derived, Derived::foo
        
        // Check inheritance edge
        let extends_edges: Vec<_> = edges.iter()
            .filter(|e| e.edge_type == EdgeType::Extends)
            .collect();
        assert_eq!(extends_edges.len(), 1);
        assert_eq!(extends_edges[0].dst, Some("Base".to_string()));
        
        Ok(())
    }

    #[test]
    fn test_parse_struct() -> Result<()> {
        let mut harness = CppHarness::new_c()?;
        let source = r#"
struct Point {
    int x;
    int y;
};
"#;
        
        let (symbols, _edges, _occurrences) = harness.parse("test.c", source)?;
        
        let struct_sym = symbols.iter().find(|s| s.name == "Point").unwrap();
        assert_eq!(struct_sym.kind, SymbolKind::Struct);
        
        Ok(())
    }

    #[test]
    fn test_parse_enum() -> Result<()> {
        let mut harness = CppHarness::new_c()?;
        let source = r#"
enum Color {
    RED,
    GREEN,
    BLUE
};
"#;
        
        let (symbols, _edges, _occurrences) = harness.parse("test.c", source)?;
        
        assert_eq!(symbols.len(), 4); // Color enum + 3 values
        
        let enum_sym = symbols.iter().find(|s| s.name == "Color").unwrap();
        assert_eq!(enum_sym.kind, SymbolKind::Enum);
        
        let red = symbols.iter().find(|s| s.name == "RED").unwrap();
        assert_eq!(red.kind, SymbolKind::EnumMember);
        assert_eq!(red.fqn, "Color.RED");
        
        Ok(())
    }

    #[test]
    fn test_parse_namespace() -> Result<()> {
        let mut harness = CppHarness::new_cpp()?;
        let source = r#"
namespace math {
    int add(int a, int b) {
        return a + b;
    }
    
    namespace utils {
        void print(int x);
    }
}
"#;
        
        let (symbols, _edges, _occurrences) = harness.parse("test.cpp", source)?;
        
        let add_sym = symbols.iter().find(|s| s.name == "add").unwrap();
        assert_eq!(add_sym.fqn, "math::add");
        
        let print_sym = symbols.iter().find(|s| s.name == "print").unwrap();
        assert_eq!(print_sym.fqn, "math::utils::print");
        
        Ok(())
    }

    #[test]
    fn test_parse_nested_classes() -> Result<()> {
        let mut harness = CppHarness::new_cpp()?;
        let source = r#"
class Outer {
public:
    class Inner {
    public:
        void innerMethod() {}
    };
    
    void outerMethod() {}
};
"#;
        
        let (symbols, _edges, _occurrences) = harness.parse("test.cpp", source)?;
        
        // Check that both classes exist
        assert!(symbols.iter().any(|s| s.name == "Outer" && s.kind == SymbolKind::Class));
        assert!(symbols.iter().any(|s| s.name == "Inner" && s.kind == SymbolKind::Class));
        
        // Check that Inner has correct FQN
        let inner = symbols.iter().find(|s| s.name == "Inner").unwrap();
        assert_eq!(inner.fqn, "Outer::Inner");
        
        // Check that innerMethod has correct FQN
        let inner_method = symbols.iter().find(|s| s.name == "innerMethod").unwrap();
        assert_eq!(inner_method.fqn, "Outer::Inner::innerMethod");
        
        Ok(())
    }
    
    #[test]
    fn test_parse_includes() -> Result<()> {
        let mut harness = CppHarness::new_c()?;
        let source = r#"
#include <stdio.h>
#include "myheader.h"
"#;
        
        let (_symbols, edges, _occurrences) = harness.parse("test.c", source)?;
        
        let import_edges: Vec<_> = edges.iter()
            .filter(|e| e.edge_type == EdgeType::Imports)
            .collect();
        
        assert_eq!(import_edges.len(), 2);
        assert!(import_edges.iter().any(|e| e.dst == Some("stdio.h".to_string())));
        assert!(import_edges.iter().any(|e| e.dst == Some("myheader.h".to_string())));
        
        Ok(())
    }

    #[test]
    fn test_parse_function_calls() -> Result<()> {
        let mut harness = CppHarness::new_c()?;
        let source = r#"
void foo() {
    printf("Hello");
}

void bar() {
    foo();
    foo();
}
"#;
        
        let (_symbols, edges, occurrences) = harness.parse("test.c", source)?;
        
        // Check call edges
        let call_edges: Vec<_> = edges.iter()
            .filter(|e| e.edge_type == EdgeType::Calls)
            .collect();
        
        assert_eq!(call_edges.len(), 3); // printf, foo, foo
        
        // Check reference occurrences
        let refs: Vec<_> = occurrences.iter()
            .filter(|o| o.role == OccurrenceRole::Reference)
            .collect();
        
        assert_eq!(refs.len(), 3);
        
        Ok(())
    }

    #[test]
    fn test_empty_file() -> Result<()> {
        let mut harness = CppHarness::new_c()?;
        let source = "";
        
        let (symbols, edges, occurrences) = harness.parse("empty.c", source)?;
        
        assert_eq!(symbols.len(), 0);
        assert_eq!(edges.len(), 0);
        assert_eq!(occurrences.len(), 0);
        
        Ok(())
    }

    #[test]
    fn test_complex_cpp_features() -> Result<()> {
        let mut harness = CppHarness::new_cpp()?;
        let source = r#"
template<typename T>
class Vector {
public:
    void push_back(const T& value);
    T& operator[](size_t index);
};

class String : public std::string {
public:
    String() = default;
    ~String() {}
};
"#;
        
        let (symbols, edges, _occurrences) = harness.parse("test.cpp", source)?;
        
        // Should parse template class and methods
        let vector = symbols.iter().find(|s| s.name == "Vector").unwrap();
        assert_eq!(vector.kind, SymbolKind::Class);
        
        let string = symbols.iter().find(|s| s.name == "String").unwrap();
        assert_eq!(string.kind, SymbolKind::Class);
        
        // Check inheritance
        let extends: Vec<_> = edges.iter()
            .filter(|e| e.edge_type == EdgeType::Extends)
            .collect();
        assert_eq!(extends.len(), 1);
        
        Ok(())
    }
}